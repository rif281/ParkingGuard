"""Parking Guard - Identification and criminalization of the
                    object {Person, car, bicycle, motorbike, bus, truck} """
import cv2 as cv
import time
from prettytable import PrettyTable
import os
from os.path import isfile, join
from os import listdir
import smtplib
import ssl
from email.message import EmailMessage
import imghdr
import shutil
import argparse

#Get camera channel from main script
parser = argparse.ArgumentParser()
parser.add_argument("cam_channel", type=str, help="Camera channel")
args = parser.parse_args()
front_back = ("Back" if args.cam_channel == "2" else "Front")


def objects(*args): # *args enable get unknown number of arguments 
    """Object list to detect"""
    object_list = []
    for object in args:
        object_list.append(object)
    return object_list


def local_time():
    """ Return the exact time according to the computer"""
    return time.ctime()


def criminalization(name, data):
    """Saving an image from the video
        in real-time"""
    cv.imwrite(f"/home/reef19/ParkingGuard/pictures/{name}.png", data)


def table_file(d, m, t, y, num, obj):
    """Export a file of the images in memory"""
    # Table of input data:
    # Header
    tables = PrettyTable(["Day", "Month", "Time", "Year", "Pic_number", "Object"])
    # Row of data:
    tables.add_row([d, m, t, y, num, obj])
    # If it is the first image:
    if num == 0:
        with open('table.txt', 'w') as f: #Creating .txt file
            f.write(str(tables))
            f.write("\n")
            
    # Else add new row:
    else:
        with open('table.txt', 'a') as f: # Add rows to excisting file
            f.write(str(tables))
            f.write("\n")
            
    # Clearing unimportant lines and organizing file for export:
    with open('table.txt', 'r') as f: # table.txt is the original table 
        with open('new_table.txt', 'w') as d: # new_table.txt is the organized table, ready to export.
            # Add header to new_table:
            d.write(f"***Detected From {front_back}***\n\n")
            d.write("| Day | Month |   Time   | Year | Pic_number | Object |")
            d.write("\n")
            d.write("+-----+-------+----------+------+------------+--------+")
            d.write("\n")
            # Filter unimportant lines:
            for line in f:
                if (line.strip('\n') == "| Day | Month |   Time   | Year | Pic_number | Object |") \
                        or (line.strip("\n") == "+-----+-------+----------+------+------------+--------+"):
                    continue
                else:
                    d.write(line)
                    d.write("\n")
                    d.write("+-----+-------+----------+------+------------+--------+")
                    d.write("\n")
        # Close files:
        d.close()
    f.close()
    

def generate_mail(email_receiver):
    """This function generate an email with relevant images and data"""
    # Define email sender
    email_sender = 'pynq.reef@gmail.com'
    email_password = 'xryctzzsftehkeme' # 'App password'- generated by gmail for link mail account to external applications.
    subject = f"New Detection files : {local_time()}"
    body =""
    # Write new table to mail body:
    with open("new_table.txt" , 'r') as f:
        lines = f.readlines()
        for line in lines:
            body += line
            
    msg = EmailMessage()
    msg['From'] = email_sender
    msg['To'] = email_receiver
    msg['Subject'] = subject
    msg.set_content(body)
    lib_path = '/home/reef19/ParkingGuard/pictures'
    # Create a list of images with full path:
    file_list = [f for f in listdir(lib_path) if isfile(join(lib_path, f))]
    
    for file in file_list:
        with open(f"{lib_path}/{file}", 'rb') as fp: # 'rb
            img_data = fp.read()
        msg.add_attachment(img_data, maintype='image', subtype=imghdr.what(None, img_data), filename=str(file))

    # Add SSL (layer of security)
    context = ssl.create_default_context()

    # Log in and send the email
    with smtplib.SMTP_SSL('smtp.gmail.com', 465, context=context) as smtp:
        smtp.login(email_sender, email_password)
        smtp.sendmail(email_sender, email_receiver, msg.as_string())
    end_script_func()

def end_script_func():
    folder = '/home/reef19/ParkingGuard/pictures'
    for filename in os.listdir(folder):
        file_path = os.path.join(folder, filename)
        try:
            if os.path.isfile(file_path) or os.path.islink(file_path):
                os.unlink(file_path)
            elif os.path.isdir(file_path):
                shutil.rmtree(file_path)
        except Exception as e:
            print('Failed to delete %s. Reason: %s' % (file_path, e))
    
    capt.release()
    cv.destroyAllWindows()
#     sys.exit()
    
    

    
def channel(num, width=1280, height=720):  # webcam & HD values as default
    """Creating a video channel and
        setting the scene values(width and height)"""
    cap = cv.VideoCapture(num)
    cap.set(cv.CAP_PROP_FRAME_WIDTH, width)
    cap.set(cv.CAP_PROP_FRAME_HEIGHT, height)
    return cap


class Detection:
    """Creating Neural Net"""

    def __init__(self, weights, cfg_file, classes_path):  # Get weights file and configuration file
        self.net = cv.dnn.readNet(weights, cfg_file)  # Generate the net of dnn
        self.model = cv.dnn_DetectionModel(self.net)  # Generate the model of the net
        self.classes = []  # classes list (objects to detect)
        with open(classes_path, 'r') as objects_file:  # Append the objects in classes
            for class_names in objects_file.readlines():
                class_names = class_names.strip()
                self.classes.append(class_names)

    def set_model(self, size):  # Set the input parameters of the model(Must be number divisible by 32)
        self.model.setInputParams(size=size, scale=1 / 255)

# Data path of the net and model
net_classes_path = "/home/reef19/ParkingGuard/dnn_model/classes.txt"
net_weights = "/home/reef19/ParkingGuard/dnn_model/yolov4-tiny.weights"
net_cfg_file = "/home/reef19/ParkingGuard/dnn_model/yolov4-tiny.cfg"
model_size = (256, 256)

# Defining the objects to be identified
detection_list = objects('person', 'bicycle', 'car', 'motorbike', 'bus', 'truck')
# Video capture
capt = channel(int(args.cam_channel))

# Initialize the image number
pic_counter = 0
# Real time process:

# Receiver mail:
rec_mail = "zah.h48@gmail.com"
while True:
    # Get frames from webcam
    ret, frame = capt.read()

    # Object detection
    my_model = Detection(net_weights, net_cfg_file, net_classes_path)
    my_model.set_model(model_size)
    if ret:
        (class_ids, scores, b_boxes) = my_model.model.detect(frame)
    else:
        break
    
    for class_id, score, b_box in zip(class_ids, scores, b_boxes):
        # Draw bounding box and class category
        (x, y, w, h) = b_box
        class_name = my_model.classes[class_id]
        if class_name in detection_list:
            if score >= 0.8:
                cv.putText(frame, class_name, (x, y - 10), cv.FONT_HERSHEY_PLAIN, 2, (0, 0, 200), 2)
                cv.rectangle(frame, (x, y), (x + w, y + h), (180, 80, 0), 3)
                img_name = local_time()
                date_list = img_name.split()
                
                criminalization(str(pic_counter), frame)
                table_file(date_list[2], date_list[1], date_list[3], date_list[4], pic_counter, class_name)
                pic_counter += 1
                percent = score * 100

                print("Object type : ", class_name, "\n")
                print("Detection score: {p:1.2f}".format(p=percent) , "% \n")
                #cv.imshow("Frame", frame)
                cv.waitKey(2)
        if pic_counter == 2:
            generate_mail(rec_mail)
            print("Email sent to : ", rec_mail)
            capt.release()
            break
